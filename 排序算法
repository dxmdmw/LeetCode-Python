经典排序算法的 Python 实现

1. 冒泡排序
属于内部排序（占用常数内存，不占用额外内存）、简单排序的一种，稳定（排序后两个相等键值的顺序和排序前顺序想同）。它重复地走访要排序的数列，一次比较前后两个元素，如果顺序错误就交换。在一次走访中，最大的元素会沉入底部（最右端），下次走访则对除最大元素的其他元素进行，直至结束。
平均时间复杂度 O(n^2)，最坏情况 O(n^2)，最好情况 O(n)
空间复杂度 O(1)

代码：

def bubbleSort(arr):
    # i 代表走访次数，取值范围在 1 至len(arr)-1之间
    for i in range(1, len(arr)):
        # j 代表遍历该轮走访中的每个元素，取值范围在 0 至 len(arr)-i-1 之间
        for j in range(0, len(arr)-i):
            # 两两比较，如位置错误就交换顺序
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
    
2. 选择排序
属于内部排序、简单排序的一种，不稳定。它选定第 i 序号的数字做基础，选出后续数列中的最小值与第 i 序号位置交换。i 遍历至 len（arr）- 2 后排序结束。
平均时间复杂度 = 最坏情况 = 最好情况 = O(n^2)，性能一般
空间复杂度 O(1)

代码：

def selectionSort(arr):
    # i 代表走访次数，第 i 轮走访将把第 i 个数变为当前最小值（除 i - 1 之前的数字）
    for i in range(len(arr)-1):
        # 首先将最小值索引参数记录为序号 i
        minIndex = i
        # 遍历序号在 i 之后的数列，如有比索引参数位数字小的，索引参数即改为它
        for j in range(i+1, len(arr)):
            if arr[j] < arr[minIndex]:
                minIndex = j
        # 如果第 i 轮 遍历出的索引参数不为 i，说明有更小的数字，交换两者位置后进行下一轮
        if minIndex != i:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr
    
3. 插入排序
属于内部排序、简单排序的一种，稳定。通过构建有序序列，对于未排序序列，在已排序序列从前向后扫描，找到相应位置并插入。
平均时间复杂度 O(n^2)，最坏情况 O(n^2)，最好情况 O(n)
空间复杂度 O(1)

代码：

def insertionSort(arr):
    # 从第二个数开始枚举 i 
    for i in range(1, len(arr)):
        # 枚举 i 之前的序号上的数字，找到 i 序上的数字应在的位置，插入该位置结束当前枚举
        for j in range(i):
            if arr[i] < arr[j]:
                arr.insert(j, arr.pop(i))
                break
    return arr
    
4. 希尔排序
属于内部排序，不稳定。也称递减增量排序算法。是插入排序的一种改进版本。
希尔排序是基于插入排序的以下两点性质提出改进的：
· 插入排序对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
· 但插入排序一般是低效的，因为每次只能将数据移动一位
希尔排序的基本思想是：先将整个待排序的序列分割成若干子序列分别进行直接插入排序，逐步缩减分隔步长，至步长为 1 时，整个序列进行一次插入排序即为所求。
平均时间复杂度 O(nlogn)，最好情况 = 最坏情况 O(n log2 n)，取决于增量公式的选择。

代码：

def shellSort(arr):
    # 初始化增量为序列长度
    gap = len(arr)
    # 循环条件为增量大于 1，即增量变为 1 时结束
    while gap > 1:
        # 选取长度的一半作为增量，后续每次循环减半
        gap = gap // 2
        # 从增量开始枚举序列号
        for i in range(gap, len(arr)):
            # 枚举按增量步长对应的序列号，判断两者大小，插入排序，然后进入下一轮循环
            for j in range(i % gap, i , gap):
                if arr[i] < arr[j]:
                    arr.insert(j, arr.pop(i))
    return arr
    
5. 快速排序
属于内部排序，不稳定。通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据小，然后对这两部分数据分别进行快速排序，递归结束即为所求。
平均时间复杂度=最好情况= O(nlogn)，最坏情况 O(n^2)，但是 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。
空间复杂度 O(logn)

代码：
def quickSort(arr):
    # 递归终止条件
    if arr == []: return []
    # 设置基准参数
    first = arr[0]
    # 对比基准参数小的序列进行快速排序
    arr_less = quickSort([l for l in arr[1:] if l < first])
    # 对比基准参数大的序列进行快速排序
    arr_more = quickSort([m for m in arr[1:] if m >= first])    
    # 返回合并排序后的结果
    return arr_less + [first] + arr_more
    
